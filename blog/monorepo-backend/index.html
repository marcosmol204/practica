<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Which Monorepo is right for a Node.js BACKEND now? | Practica.js</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://practica.dev/blog/monorepo-backend"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Which Monorepo is right for a Node.js BACKEND now? | Practica.js"><meta data-rh="true" name="description" content="As a Node.js starter, choosing the right libraries and frameworks for our users is the bread and butter of our work in Practica.js. In this post, we&#x27;d like to share our considerations in choosing our monorepo tooling"><meta data-rh="true" property="og:description" content="As a Node.js starter, choosing the right libraries and frameworks for our users is the bread and butter of our work in Practica.js. In this post, we&#x27;d like to share our considerations in choosing our monorepo tooling"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-09-15T22:06:11.000Z"><meta data-rh="true" property="article:author" content="https://github.com/goldbergyoni,https://github.com/mikicho"><meta data-rh="true" property="article:tag" content="monorepo,decisions"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://practica.dev/blog/monorepo-backend"><link data-rh="true" rel="alternate" href="https://practica.dev/blog/monorepo-backend" hreflang="en"><link data-rh="true" rel="alternate" href="https://practica.dev/blog/monorepo-backend" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Practica.js RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Practica.js Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-71456305-3","auto"),ga("set","anonymizeIp",!0),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script><link rel="stylesheet" href="/assets/css/styles.631f09a8.css">
<link rel="preload" href="/assets/js/runtime~main.4297c4c1.js" as="script">
<link rel="preload" href="/assets/js/main.635e4442.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/practica.png" alt="Practica.js Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/practica.png" alt="Practica.js Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Practica.js</b></a><a href="https://www.youtube.com/channel/UCKrSJ0-jm7YVTM_hO7Me9eA" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">YouTube</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/practicajs/practica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/monorepo-backend">Which Monorepo is right for a Node.js BACKEND now?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/popular-nodejs-pattern-and-tools-to-reconsider">Popular Node.js patterns and tools to re-consider</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/practica-is-alive">Practica.js v0.0.1 is alive</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Which Monorepo is right for a Node.js BACKEND now?</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-09-15T22:06:11.000Z" itemprop="datePublished">September 15, 2022</time> · <!-- -->17 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/goldbergyoni" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/goldbergyoni.png" alt="Yoni Goldberg"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/goldbergyoni" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Yoni Goldberg</span></a></div><small class="avatar__subtitle" itemprop="description">Practica.js core maintainer</small></div></div></div><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/mikicho" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/11459632?v=4" alt="Michael Salomon"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/mikicho" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Michael Salomon</span></a></div><small class="avatar__subtitle" itemprop="description">Practica.js core maintainer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>As a Node.js starter, choosing the right libraries and frameworks for our users is the bread and butter of our work in <a href="https://github.com/practicajs/practica" target="_blank" rel="noopener noreferrer">Practica.js</a>. In this post, we&#x27;d like to share our considerations in choosing our monorepo tooling</p><p><img loading="lazy" alt="Monorepos" src="/assets/images/monorepo-high-level-291b29cc962144a43d78143889ba5d3b.png" width="1400" height="796" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-are-we-lookingat">What are we looking at<a class="hash-link" href="#what-are-we-lookingat" title="Direct link to heading">​</a></h2><p>The Monorepo market is hot like fire. Weirdly, now when the demand for Monoreps is exploding, one of the leading libraries —  <a href="https://github.com/lerna/lerna/issues/2703" target="_blank" rel="noopener noreferrer">Lerna- has just retired.</a>  When looking closely, it might not be just a coincidence — With so many disruptive and shiny features brought on by new vendors, Lerna failed to keep up with the pace and stay relevant. This bloom of new tooling gets many confused — What is the right choice for my next project? What should I look at when choosing a Monorepo tool? This post is all about curating this information overload, covering the new tooling, emphasizing what is important, and finally share some recommendations. If you are here for tools and features, you’re in the right place, although you might find yourself on a soul-searching journey to what is your desired development workflow.</p><p>This post is concerned with backend-only and Node.js. It also scoped to  <em>typical</em>  business solutions. If you’re Google/FB developer who is faced with 8,000 packages — sorry, you need special gear. Consequently, monster Monorepo tooling like  <a href="https://github.com/thundergolfer/example-bazel-monorepo" target="_blank" rel="noopener noreferrer">Bazel</a>  is left-out. We will cover here some of the most popular Monorepo tools including Turborepo, Nx, PNPM, Yarn/npm workspace, and Lerna (although it’s not actually maintained anymore — it’s a good baseline for comparison).</p><p>Let’s start? When human beings use the term Monorepo, they typically refer to one or more of the following  <em>4 layers below.</em> Each one of them can bring value to your project, each has different consequences, tooling, and features:</p><h1>Layer 1: Plain old folders to stay on top of your code</h1><p>With zero tooling and only by having all the Microservice and libraries together in the same root folder, a developer gets great management perks and tons of value: Navigation, search across components, deleting a library instantly, debugging,  <em>quickly</em>  adding new components. Consider the alternative with multi-repo approach — adding a new component for modularity demands opening and configuring a new  GitHub  repository. Not just a hassle but also greater chances of developers choosing the short path and including the new code in some semi-relevant existing package. In plain words, zero-tooling Monorepos can increase modularity.</p><p>This layer is often overlooked. If your codebase is not huge and the components are highly decoupled (more on this later)— it might be all you need. We’ve seen a handful of successful Monorepo solutions without any special tooling.</p><p>With that said, some of the newer tools augment this experience with interesting features:</p><ul><li>Both  <a href="https://turborepo.org/" target="_blank" rel="noopener noreferrer">Turborepo</a>  and  <a href="https://nx.dev/structure/dependency-graph" target="_blank" rel="noopener noreferrer">Nx</a>  and also  <a href="https://www.npmjs.com/package/lerna-dependency-graph" target="_blank" rel="noopener noreferrer">Lerna</a>  provide a visual representation of the packages’ dependencies</li><li><a href="https://nx.dev/structure/monorepo-tags" target="_blank" rel="noopener noreferrer">Nx allows ‘visibility rules’</a>  which is about enforcing who can use what. Consider, a ‘checkout’ library that should be approached only by the ‘order Microservice’ — deviating from this will result in failure during development (not runtime enforcement)</li></ul><p><img loading="lazy" src="https://miro.medium.com/max/1400/0*pHZKRlGT6iOKCmzg.jpg" class="img_ev3q"></p><p>Nx dependencies graph</p><ul><li><a href="https://nx.dev/generators/workspace-generators" target="_blank" rel="noopener noreferrer">Nx workspace generator</a>  allows scaffolding out components. Whenever a team member needs to craft a new controller/library/class/Microservice, she just invokes a CLI command which products code based on a community or organization template. This enforces consistency and best practices sharing</li></ul><h1>Layer 2: Tasks and pipeline to build your code efficiently</h1><p>Even in a world of autonomous components, there are management tasks that must be applied in a batch like applying a security patch via npm update, running the tests of  <em>multiple</em>  components that were affected by a change, publish 3 related libraries to name a few examples. All Monorepo tools support this basic functionality of invoking some command over a group of packages. For example, Lerna, Nx, and Turborepo do.</p><p><img loading="lazy" src="https://miro.medium.com/max/1400/1*wu7xtN97-Ihz4uCSDwd0mA.png" class="img_ev3q"></p><p>Apply some commands over multiple packages</p><p>In some projects, invoking a cascading command is all you need. Mostly if each package has an autonomous life cycle and the build process spans a single package (more on this later). In some other types of projects where the workflow demands testing/running and publishing/deploying many packages together — this will end in a terribly slow experience. Consider a solution with hundred of packages that are transpiled and bundled — one might wait minutes for a wide test to run. While it’s not always a great practice to rely on wide/E2E tests, it’s quite common in the wild. This is exactly where the new wave of Monorepo tooling shines —  <em>deeply</em>  optimizing the build process. I should say this out loud: These tools bring beautiful and innovative build optimizations:</p><ul><li><strong>Parallelization —</strong> If two commands or packages are orthogonal to each other, the commands will run in two different threads or processes. Typically your quality control involves testing, lining, license checking, CVE checking — why not parallelize?</li><li><strong>Smart execution plan —</strong>Beyond parallelization, the optimized tasks execution order is determined based on many factors. Consider a build that includes A, B, C where A, C depend on B — naively, a build system would wait for B to build and only then run A &amp; C. This can be optimized if we run A &amp; C’s  <em>isolated</em>  unit tests  <em>while</em> building B and not afterward. By running task in parallel as early as possible, the overall execution time is improved — this has a remarkable impact mostly when hosting a high number of components. See below a visualization example of a pipeline improvement</li></ul><p><img loading="lazy" src="https://miro.medium.com/max/1400/0*C6cxCblQU8ckTIQk.png" class="img_ev3q"></p><p>A modern tool advantage over old Lerna. Taken from Turborepo website</p><ul><li><strong>Detect who is affected by a change —</strong>  Even on a system with high coupling between packages, it’s usually not necessary to run  <em>all</em> packages rather than only those who are affected by a change. What exactly is ‘affected’? Packages/Microservices that depend upon another package that has changed. Some of the toolings can ignore minor changes that are unlikely to break others. This is not a great performance booster but also an amazing testing feature —developers can get quick feedback on whether any of their clients were broken. Both Nx and Turborepo support this feature. Lerna can tell only which of the Monorepo package has changed</li><li><strong>Sub-systems (i.e., projects) —</strong> Similarly to ‘affected’ above, modern tooling can realize portions of the graph that are inter-connected (a project or application) while others are not reachable by the component in context (another project) so they know to involve only packages of the relevant group</li><li><strong>Caching —</strong> This is a serious speed booster: Nx and Turborepo cache the result/output of tasks and avoid running them again on consequent builds if unnecessary. For example, consider long-running tests of a Microservice, when commanding to re-build this Microservice, the tooling might realize that nothing has changed and the test will get skipped. This is achieved by generating a hashmap of all the dependent resources — if any of these resources haven’t change, then the hashmap will be the same and the task will get skipped. They even cache the stdout of the command, so when you run a cached version it acts like the real thing — consider running 200 tests, seeing all the log statements of the tests, getting results over the terminal in 200 ms, everything acts like ‘real testing while in fact, the tests did not run at all rather the cache!</li><li><strong>Remote caching —</strong> Similarly to caching, only by placing the task’s hashmaps and result on a global server so further executions on other team member’s computers will also skip unnecessary tasks. In huge Monorepo projects that rely on E2E tests and must build all packages for development, this can save a great deal of time</li></ul><h1>Layer 3: Hoist your dependencies to boost npm installation</h1><p>The speed optimizations that were described above won’t be of help if the bottleneck is the big bull of mud that is called ‘npm install’ (not to criticize, it’s just hard by nature). Take a typical scenario as an example, given dozens of components that should be built, they could easily trigger the installation of thousands of sub-dependencies. Although they use quite similar dependencies (e.g., same logger, same ORM), if the dependency version is not equal then npm will duplicate (<a href="https://rushjs.io/pages/advanced/npm_doppelgangers/" target="_blank" rel="noopener noreferrer">the NPM doppelgangers problem</a>) the installation of those packages which might result in a long process.</p><p>This is where the workspace line of tools (e.g., Yarn workspace, npm workspaces, PNPM) kicks in and introduces some optimization — Instead of installing dependencies inside each component ‘NODE_MODULES’ folder, it will create one centralized folder and link all the dependencies over there. This can show a tremendous boost in install time for huge projects. On the other hand, if you always focus on one component at a time, installing the packages of a single Microservice/library should not be a concern.</p><p>Both Nx and Turborepo can rely on the package manager/workspace to provide this layer of optimizations. In other words, Nx and Turborepo are the layer above the package manager who take care of optimized dependencies installation.</p><p><img loading="lazy" src="https://miro.medium.com/max/1400/1*dhyCWSbzpIi5iagR4OB4zQ.png" class="img_ev3q"></p><p>On top of this, Nx introduces one more non-standard, maybe even controversial, technique: There might be only ONE package.json at the root folder of the entire Monorepo. By default, when creating components using Nx, they will not have their own package.json! Instead, all will share the root package.json.  Going this way, all the Microservice/libraries share their dependencies and the installation time is improved.  Note: It’s possible to create ‘publishable’ components that do have a package.json, it’s just not the default.</p><p>I’m concerned here. Sharing dependencies among packages increases the coupling, what if Microservice1 wishes to bump dependency1 version but Microservice2 can’t do this at the moment? Also, package.json is part of Node.js  <em>runtime</em> and excluding it from the component root loses important features like package.json main field or ESM exports (telling the clients which files are exposed). I ran some POC with Nx last week and found myself blocked — library B was wadded, I tried to import it from Library A but couldn’t get the ‘import’ statement to specify the right package name. The natural action was to open B’s package.json and check the name, but there is no Package.json… How do I determine its name? Nx docs are great, finally, I found the answer, but I had to spend time learning a new ‘framework’.</p><h1>Stop for a second: It’s all about your workflow</h1><p>We deal with tooling and features, but it’s actually meaningless evaluating these options before determining whether your preferred workflow is  <em>synchronized or independent</em> (we will discuss this in a few seconds)<em>.</em> This upfront  <em>fundamental</em>  decision will change almost everything.</p><p>Consider the following example with 3 components: Library 1 is introducing some major and breaking changes, Microservice1 and Microservice2 depend upon Library1 and should react to those breaking changes. How?</p><p><strong>Option A — The synchronized workflow-</strong> Going with this development style, all the three components will be developed and deployed in one chunk  <em>together</em>. Practically, a developer will code the changes in Library1, test libray1 and also run wide integration/e2e tests that include Microservice1 and Microservice2. When they&#x27;re ready, the version of all components will get bumped. Finally, they will get deployed  <em>together.</em></p><p>Going with this approach, the developer has the chance of seeing the full flow from the client&#x27;s perspective (Microservice1 and 2), the tests cover not only the library but also through the eyes of the clients who actually use it. On the flip side, it mandates updating all the depend-upon components (could be dozens), doing so increases the risk’s blast radius as more units are affected and should be considered before deployment. Also, working on a large unit of work demands building and testing more things which will slow the build.</p><p><strong>Option B — Independent workflow-</strong> This style is about working a unit by unit, one bite at a time, and deploy each component independently based on its personal business considerations and priority. This is how it goes: A developer makes the changes in Library1, they must be tested carefully in the scope of Library1. Once she is ready, the SemVer is bumped to a new major and the library is published to a package manager registry (e.g., npm). What about the client Microservices? Well, the team of Microservice2 is super-busy now with other priorities, and skip this update for now (the same thing as we all delay many of our npm updates,). However, Microservice1 is very much interested in this change — The team has to pro-actively update this dependency and grab the latest changes, run the tests and when they are ready, today or next week — deploy it.</p><p>Going with the independent workflow, the library author can move much faster because she does not need to take into account 2 or 30 other components — some are coded by different teams. This workflow also  <em>forces her</em>  to write efficient tests against the library — it’s her only safety net and is likely to end with autonomous components that have low coupling to others. On the other hand, testing in isolation without the client’s perspective loses some dimension of realism. Also, if a single developer has to update 5 units — publishing each individually to the registry and then updating within all the dependencies can be a little tedious.</p><p><img loading="lazy" src="https://miro.medium.com/max/1400/1*eeJFL3_vo5tCrWvVY-surg.png" class="img_ev3q"></p><p>Synchronized and independent workflows illustrated</p><p><strong>On the illusion of synchronicity</strong></p><p>In distributed systems, it’s not feasible to achieve 100% synchronicity — believing otherwise can lead to design faults. Consider a breaking change in Microservice1, now its client Microservice2 is adapting and ready for the change. These two Microservices are deployed together but due to the nature of Microservices and distributed runtime (e.g., Kubernetes) the deployment of Microservice1 only fail. Now, Microservice2’s code is not aligned with Microservice1 production and we are faced with a production bug. This line of failures can be handled to an extent also with a synchronized workflow — The deployment should orchestrate the rollout of each unit so each one is deployed at a time. Although this approach is doable, it increased the chances of large-scoped rollback and increases deployment fear.</p><p>This fundamental decision, synchronized or independent, will determine so many things — Whether performance is an issue or not at all (when working on a single unit), hoisting dependencies or leaving a dedicated node_modules in every package’s folder, and whether to create a local link between packages which is described in the next paragraph.</p><h1>Layer 4: Link your packages for immediate feedback</h1><p>When having a Monorepo, there is always the unavoidable dilemma of how to link between the components:</p><p><strong>Option 1: Using npm —</strong> Each library is a standard npm package and its client installs it via the standards npm commands. Given Microservice1 and Library1, this will end with two copies of Library1: the one inside Microservices1/NODE_MODULES (i.e., the local copy of the consuming Microservice), and the 2nd is the development folder where the team is coding Library1.</p><p><strong>Option2: Just a plain folder —</strong> With this, Library1 is nothing but a logical module inside a folder that Microservice1,2,3 just locally imports. NPM is not involved here, it’s just code in a dedicated folder. This is for example how Nest.js modules are represented.</p><p>With option 1, teams benefit from all the great merits of a package manager — SemVer(!), tooling, standards, etc. However, should one update Library1, the changes won’t get reflected in Microservice1 since it is grabbing its copy from the npm registry and the changes were not published yet. This is a fundamental pain with Monorepo and package managers — one can’t just code over multiple packages and test/run the changes.</p><p>With option 2, teams lose all the benefits of a package manager: Every change is propagated immediately to all of the consumers.</p><p>How do we bring the good from both worlds (presumably)? Using linking. Lerna, Nx, the various package manager workspaces (Yarn, npm, etc) allow using npm libraries and at the same time link between the clients (e.g., Microservice1) and the library. Under the hood, they created a symbolic link. In development mode, changes are propagated immediately, in deployment time — the copy is grabbed from the registry.</p><p><img loading="lazy" src="https://miro.medium.com/max/1400/1*9PkNrnbnibFdbvPieq-y9g.png" class="img_ev3q"></p><p>Linking packages in a Monorepo</p><p>If you’re doing the synchronized workflow, you’re all set. Only now any risky change that is introduced by Library3, must be handled NOW by the 10 Microservices that consume it.</p><p>If favoring the independent workflow, this is of course a big concern. Some may call this direct linking style a ‘monolith monorepo’, or maybe a ‘monolitho’. However, when not linking, it’s harder to debug a small issue between the Microservice and the npm library. What I typically do is  <em>temporarily link</em> (with npm link) between the packages<em>,</em>  debug, code, then finally remove the link.</p><p>Nx is taking a slightly more disruptive approach — it is using  <a href="https://www.typescriptlang.org/tsconfig#paths" target="_blank" rel="noopener noreferrer">TypeScript paths</a>  to bind between the components. When Microservice1 is importing Library1, to avoid the full local path, it creates a TypeScript mapping between the library name and the full path. But wait a minute, there is no TypeScript in production so how could it work? Well, in serving/bundling time it webpacks and stitches the components together. Not a very standard way of doing Node.js work.</p><h1>Closing: What should you use?</h1><p>It’s all about your workflow and architecture — a huge unseen cross-road stands in front of the Monorepo tooling decision.</p><p><strong>Scenario A —</strong> If your architecture dictates a  <em>synchronized workflow</em>  where all packages are deployed together, or at least developed in collaboration — then there is a strong need for a rich tool to manage this coupling and boost the performance. In this case, Nx might be a great choice.</p><p>For example, if your Microservice must keep the same versioning, or if the team really small and the same people are updating all the components, or if your modularization is not based on package manager but rather on framework-own modules (e.g., Nest.js), if you’re doing frontend where the components inherently are published together, or if your testing strategy relies on E2E mostly — for all of these cases and others, Nx is a tool that was built to enhance the experience of coding many  <em>relatively</em> coupled components together. It is a great a sugar coat over systems that are unavoidably big and linked.</p><p>If your system is not inherently big or meant to synchronize packages deployment, fancy Monorepo features might increase the coupling between components. The Monorepo pyramid above draws a line between basic features that provide value without coupling components while other layers come with an architectural price to consider. Sometimes climbing up toward the tip is worth the consequences, just make this decision consciously.</p><p><img loading="lazy" src="https://miro.medium.com/max/1400/1*c2qYYpVGG667bkum-gB-5Q.png" class="img_ev3q"></p><p><strong>Scenario B—</strong> If you’re into an  <em>independent workflow</em> where each package is developed, tested, and deployed (almost) independently — then inherently there is no need to fancy tools to orchestrate hundreds of packages. Most of the time there is just one package in focus. This calls for picking a leaner and simpler tool — Turborepo. By going this route, Monorepo is not something that affects your architecture, but rather a scoped tool for faster build execution. One specific tool that encourages an independent workflow is  <a href="https://github.com/giltayar/bilt" target="_blank" rel="noopener noreferrer">Bilt</a>  by Gil Tayar, it’s yet to gain enough popularity but it might rise soon and is a great source to learn more about this philosophy of work.</p><p><strong>In any scenario, consider workspaces —</strong> If you face performance issues that are caused by package installation, then the various workspace tools Yarn/npm/PNPM, can greatly minimize this overhead with a low footprint. That said, if you’re working in an autonomous workflow, smaller are the chances of facing such issues. Don’t just use tools unless there is a pain.</p><p>We tried to show the beauty of each and where it shines. If we’re allowed to end this article with an opinionated choice: We greatly believe in an independent and autonomous workflow where the occasional developer of a package can code and deploy fearlessly without messing with dozens of other foreign packages. For this reason, Turborepo will be our favorite tool for the next season. We promise to tell you how it goes.</p><h1>Bonus: Comparison table</h1><p>See below a detailed comparison table of the various tools and features:</p><p><img loading="lazy" src="https://miro.medium.com/max/1400/1*iHX_IdPW8XXXiZTyjFo6bw.png" class="img_ev3q"></p><p>Preview only, the complete table can be  <a href="https://github.com/practicajs/practica/blob/main/docs/docs/decisions/monorepo.md" target="_blank" rel="noopener noreferrer">found here</a></p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/monorepo">monorepo</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/decisions">decisions</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/practicajs/practica/tree/main/docs/blog/which-monorepo/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/popular-nodejs-pattern-and-tools-to-reconsider"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Popular Node.js patterns and tools to re-consider</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-are-we-lookingat" class="table-of-contents__link toc-highlight">What are we looking at</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/practicajs" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://discord.gg/QxuPmV5w" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/practicajs/practica" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Practica.js</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4297c4c1.js"></script>
<script src="/assets/js/main.635e4442.js"></script>
</body>
</html>